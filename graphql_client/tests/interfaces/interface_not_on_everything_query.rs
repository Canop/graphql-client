pub mod interface_not_on_everything_query { # ! [ allow ( non_camel_case_types ) ] # ! [ allow ( non_snake_case ) ] # ! [ allow ( dead_code ) ] use serde ; pub const OPERATION_NAME : & 'static str = "InterfaceNotOnEverythingQuery" ; pub const QUERY : & 'static str = "query InterfaceNotOnEverythingQuery {\n  everything {\n    __typename\n    name\n    ... on Person {\n      birthday\n    }\n    ... on Organization {\n      industry\n    }\n  }\n}\n" ; use serde_derive :: * ; # [ allow ( dead_code ) ] type Boolean = bool ; # [ allow ( dead_code ) ] type Float = f64 ; # [ allow ( dead_code ) ] type Int = i64 ; # [ allow ( dead_code ) ] type ID = String ; # [ derive ( Eq , PartialEq ) ] pub enum Industry { CAT_FOOD , CHOCOLATE , OTHER , Other ( String ) , } impl :: serde :: Serialize for Industry { fn serialize < S : serde :: Serializer > ( & self , ser : S ) -> Result < S :: Ok , S :: Error > { ser . serialize_str ( match * self { Industry :: CAT_FOOD => "CAT_FOOD" , Industry :: CHOCOLATE => "CHOCOLATE" , Industry :: OTHER => "OTHER" , Industry :: Other ( ref s ) => & s , } ) } } impl < 'de > :: serde :: Deserialize < 'de > for Industry { fn deserialize < D : :: serde :: Deserializer < 'de >> ( deserializer : D ) -> Result < Self , D :: Error > { let s = < String > :: deserialize ( deserializer ) ? ; match s . as_str ( ) { "CAT_FOOD" => Ok ( Industry :: CAT_FOOD ) , "CHOCOLATE" => Ok ( Industry :: CHOCOLATE ) , "OTHER" => Ok ( Industry :: OTHER ) , _ => Ok ( Industry :: Other ( s ) ) , } } } # [ derive ( Deserialize ) ] pub struct InterfaceNotOnEverythingQueryEverythingOnOrganization { pub industry : Industry , } # [ derive ( Deserialize ) ] pub struct InterfaceNotOnEverythingQueryEverythingOnPerson { pub birthday : Option < String > , } # [ derive ( Deserialize ) ] # [ serde ( tag = "__typename" ) ] pub enum InterfaceNotOnEverythingQueryEverythingOn { Organization ( InterfaceNotOnEverythingQueryEverythingOnOrganization ) , Person ( InterfaceNotOnEverythingQueryEverythingOnPerson ) , Dog , } # [ derive ( Deserialize ) ] pub struct InterfaceNotOnEverythingQueryEverything { pub name : String , # [ serde ( flatten ) ] pub on : InterfaceNotOnEverythingQueryEverythingOn , } # [ derive ( Serialize ) ] pub struct Variables ; # [ derive ( Deserialize ) ] pub struct ResponseData { pub everything : Option < Vec < InterfaceNotOnEverythingQueryEverything > > , } impl :: graphql_client :: GraphQLQuery for super :: InterfaceNotOnEverythingQuery { type Variables = Variables ; type ResponseData = ResponseData ; fn build_query ( variables : Self :: Variables ) -> :: graphql_client :: QueryBody < Self :: Variables > { :: graphql_client :: QueryBody { variables , query : QUERY , operation_name : OPERATION_NAME , } } } }